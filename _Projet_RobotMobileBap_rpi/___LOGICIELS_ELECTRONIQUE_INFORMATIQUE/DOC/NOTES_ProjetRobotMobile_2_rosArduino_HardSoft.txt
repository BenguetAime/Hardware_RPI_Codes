############ Start - Hardware-Software / Moteur et suite… ############
>> GEAR MOTOR :
- 
https://stackoverflow.com/questions/74481393/arduino-mega-with-l298n-and-motors-with-encoders-not-registering-encoders

-My GM25-370 :
https://www.robot-maker.com/shop/kits-robots/51-kit-moteur-gm25-370ca-encodeur-roue-chromee-51.html
- YouTube with GM25-370 motor :
https://www.youtube.com/watch?v=n7HOUla5MOw
- Arituclated robotics :
https://www.youtube.com/watch?v=-PCuDnpgiew&list=PLunhqkrRNRhYAffV8JDiFOatQXuU-NnxT&index=7
- Arduino ANALOG/DIGITAL : 
https://www.youtube.com/watch?v=BMMnOAzcqoE

________>> Logiciel GIMP - modif photos_________ :
https://www.youtube.com/watch?v=t8LAXxqfqWk

>> free -h : mémoire


############ End - Hardware-Software / Moteur et suite… ############






############ START - NOTES ##########
____!! ROSSERIAL : - ROS 1!! ____
>>
https://wiki.ros.org/rosserial

https://wiki.ros.org/rosserial_arduino/Tutorials
>>

_Installer rosserial pour ROS 2 sur le Raspberry Pi :
sudo apt install ros-humble-rosserial
sudo apt install ros-humble-rosserial-Arduino


__Configurer et programmer l'Arduino Mega :
Connectez l'Arduino Mega à votre Raspberry Pi via USB (port série).
-Installez Arduino IDE sur le Raspberry Pi, si ce n'est pas déjà fait, et ouvrez-le.
-Installez la bibliothèque rosserial_arduino :
-Ouvrez Arduino IDE.
-Allez dans Sketch > Include Library > Manage Libraries.
-Recherchez rosserial_arduino et installez-la.
---------------------------------------------


---------------------------------------------
____!!!! ros2-arduino : - ROS 2!!!! ____ PB DE MEMOIRE SRAM avec ARDUINO MEGA??
https://docs.arduino.cc/libraries/ros2arduino/

https://github.com/ROBOTIS-GIT/ros2arduino

---
___Raspberry Pi, Ros2/ARDUINO
Conclusion
Arduino et Raspberry Pi communiquent via ROS 2 sans utiliser le port série traditionnel en utilisant rosserial ou un pont ROS 2.
Le Raspberry Pi exécute ROS 2 et sert de passerelle pour l'Arduino, tandis que l'Arduino envoie des messages via un nœud ROS 2.
Vous pouvez créer des nœuds ROS 2 sur le Raspberry Pi pour interagir avec les capteurs et les actionneurs de l'Arduino.

--------------------------------------------




########################
>> Alternative à "sudo raspi-config", sous ubuntu:
sudo nano /boot/firmware/config.txt

>> ____! !!!!!  UTILISATION DE ~/.bashrc !!!!!!___
Y AJOUTER DES LIGNES : 
source /home/ubuntu/chemin_vers_mon_ws_ros/install/setup.bash

ON peut sourcer ensuite ce fichier caché :
>> source ~/.bashrc : plus besoin de faire source install/setup.bash le workspace ros utilisé.
########################





############################# Suite projet - LIDAR - ROS2
>> ARTICULATED ROBOTICS :
https://www.youtube.com/watch?v=eJZXRncGaGM&list=PLunhqkrRNRhYAffV8JDiFOatQXuU-NnxT&index=8

>> Autre source:
https://automaticaddison.com/set-up-lidar-for-a-simulated-mobile-robot-in-ros-2/

>> Autre source - ld19 lidar :
https://www.waveshare.com/wiki/Tutorial_IX_Lidar_and_Publishing_Lidar_Topics_in_ROS2#:~:text=Connect%20LD19%20and%20the%20driver,LiDAR%20written%20next%20to%20it.

-------
>> ros2 topic echo /topic_name

__ADD A lidar.xacro in robot_urdf.xacro :
Tout comme gazebo_control.xacro gérant le diff_drive driver, a été inclus.
>> Dans le lidar.xacro, chercher le tag << visualize>> : le metttre à true pour voir les données lidar (faisceaux);

__ Pour utiliser le vrai lidar - LD19:
--- Se servir du driver fournit par le constructeur!
- Un nœud ROS2 (lancé via un fichier .launch (ld19.launch.py)) permet de préciser : 
le port par lequel le lidar est connecté, le frame_id (nom du link lidar simulé), etc.
Lancer ce nœud permet de gérer les données lidar : les envoyés sur /scan;
- Un autre nœud éventuellement, lance rviz2;


- Mon cas :LIDAR LD19
>>
sud chmod 777 /dev/ttyUSB0
>> https://github.com/ldrobotSensorTeam
>> https://github.com/ldrobotSensorTeam/ldlidar_stl_ros2

-------

#############################  Suite projet - LIDAR - ROS2








############################# Suite projet - CAMERA - ROS2

---------------------------------
>> Pour lancer la simulation de la caméra : éviter la communication entre les machines ROS2
---------------------------------



>> ARTICULATED ROBOTICS :
https://www.youtube.com/watch?v=A3nw2M47K50&list=PLunhqkrRNRhYAffV8JDiFOatQXuU-NnxT&index=9

___ Simuler la caméra via camera.xacro, et inclure ce fichier dans le fichier .xacro global.
- Ne pas oublier d'avoir le plugin camera dans ce fichier camera.xacro (un peu comme avec le lidar, avec des adaptations);
- Ne pas oublier de lier le plugin camera, au joint 'optical joint'(on l'appelle comme on veut), qui représente :+x  à droite horizontal,+y: en bas vertical,+z:sortant; Le repère pour les images.

___Ouvrir rviz2 :
>> fixed frame: odom
>> ADD / Image display (une image apparaît): topic=/camera/Image_raw
>> ADD/ Camera display (une grille apparaît: donne où l'image se trouve dans le monde): topic=/camera/Image_raw

_______Sur les 2 displays ajoutés, dans les topic, ON NE VOIT PAS LES TOPIC LIES AUX "images compressées (jpeg, png...)"; Ceci est dû au fait qu'il nous faut INSTALLER Le plugin utile à cela :

--------
>> sudo apt install ros-humble-image-transport-plugins
On a désormais les topic permettant de récupérer des images compressées.

>> I on fait : IMAGE display, topic=/camera/image_raw/compressed
---!! No image ---!!
---CECI, du fait que Rviz2 ne gère pas les images compresses, il faut à nouveau INSTALLER quelque chose (qui nous permet de voir les TOPICS liés aux données compressées ou non):

---------
>> sudo apt install ros-humble-rqt-image-view
>> ros2 run rqt_image_view rqt_image_view


____!!! En travaillant avec une vraie caméra, si les constructeur/fournisseurs n'ont pas bien construit le driver, on peut ne recevoir que les données compressées OU les non compressées!
___!!!
- commment créer un topic compressed OU non, si on en manque:
-
>> ros2 run image_transport list_transports
CECI NOUS DIT: tous les types de données images que notre système connaît à cet instant (image_transport/compressed; image_transport/compressedDepth; image_transport/raw, etc).

- Pour prendre des données d'un topic propre à un type de données images vers un autre topic propre à un autre type:
-
>> ros2 run image_transport republish _input_format _output_format __then_remapping_of_the_topic__

>> ros2 run image_transport republish compressed raw --ros-args -r in/compressed:=/camera/image_raw/compressed -r out:=/camera/image_raw/uncompressed






____________ REAL CAMERA - START ___________

>> v4l : video for linux; 

--- IL Y A DE MULTIPLE MANIERE DE LE FAIRE, OU MIEUX, <<ceci marchait dans mon cas>>!


-------- FAIRE OBLIGATOIREMENT - start :
****>>>>>> sudo apt install libraspberrypi-bin v4l-utils ros-humble-v4l2-camera

-- Using Pi camera ROS2 - ubuntu 22.04
https://www.youtube.com/watch?v=va7o7wzhEE4
-- cette vidéo AMENE A INSTALLER RASPI CONFIG:
>>>>> sudo apt-get install raspi-config
>>>>> sudo raspi-conig ; LANCER L'interface graphique


****** PROBLEME ****
EN LANCANT POUR LA 1RE FOIS :
>> vcgencmd get_camera : 
=> supported=0,detected=0,libcamera interfaces=0;

* POUR REGLER CE PROBLEME, J'AI LU LA VIDEO (LIEN PRECEDENT) RECOMMANDANT DE TELECHARGER "sudo apt-get raspi-config" (activation de l'interface caméra, I2C,SPI); 
*CECI A CONDUIT A :
=> supported=1,detected=0,libcamera interfaces=1;

* EN OUVRANT LE FICHIER 
>>"ubuntu@princeB:~$ sudo nano /boot/firmware/config.txt"
J'AI OBSERVE LA PRESENCE DE "dtoverlay=imx219" : 
CECI EST RECOMMANDE DANS LE TUTORIEL CAMERA V2 RPI (Qui est sans pb sous RASPBERRY PI OS, pour utiliser LICAMERA?!); SOUS UBUNTU, mon cas, EN COMMENTANT CETTE LIGNE, j'obtiens:
=>supported=1,detected=1,libcamera interfaces=0;

* LA CAMERA PEUT DESORMAIS ETRE UTILISER COMME DANS LE TUTORIEL DE "ARTICULATED ROBOTICS"
(https://www.youtube.com/watch?v=A3nw2M47K50&list=PLunhqkrRNRhYAffV8JDiFOatQXuU-NnxT&index=13), 
ET PLUS VIA "libcamera"(simple sous raspberry pi OS);

-------- FAIRE OBLIGATOIREMENT - end --------


_____ suite….REAL CAMERA

>> groups : voir si l'utilisateur est dans le video groups
(d'près ARTICULATED ROBOTICS : sudo usermod -aG video ubuntu )

>> SINON: sudo usermod -a -G video <username=ubuntu, dans mon cas> : je l'ai testé dans un premier temps; 
>> sudo reboot éventuellement
-
>> VERIFIER SI LA CAMERA EST CONNECTEE :
>> vcgencmd get_camera (LE RESTE EST SIMPLE SSI LA CAMERA EST DETECTEE )
https://www.raspberrypi.org/documentation/computers/os.html#vcgencmd

- POUR Récupérer les données de la caméra :
>>>>>>>>>>> raspistill -k


_______ suite…. REAL CAMERA
**** Installer le package v4l2_camera (cela a déjà été fait plus haut dans "FAIRE OBLIGATOIREMENT - start")
-- Le package v4l2_camera 
permet à ROS 2 d'utiliser des caméras vidéo basées sur V4L2. Si vous ne l'avez pas encore installé, vous devez le faire avec la commande suivante :
 (>>>>> sudo apt install ros-<ros2-distro>-v4l2-camera)
>> ros2 run v4l2_camera v4l2_camera_node --ros-args -p image_size:="[800,608]" -p camera_frame_id:=camera_link_optical -p device_id:="/dev/video0"

>> si possible : 
ros2 run v4l2_camera v4l2_camera_node --ros-args --params-file path/to/your_config.yaml


_______ suite…. REAL CAMERA

- Vérifier si v4l2 peut VOIR  :
>> v4l2-ctl --list-devices; (/dev/video : ce qu'il faut vérifier)
>> v4l2-ctl --device=/dev/video0 --all

---- v4l topo :
>> https://medium.com/@deepeshdeepakdd2/v4l-a-complete-practical-tutorial-c520f097b590
----
800x608??
----
(perso : >> dpkg | grep -i camera)

---
>>>>> 
sudo apt remove --purge libcamera-dev libcamera-tools libcamera0
?????????
---

------------- EVENTUELLEMENT (PERSO !!!): ATTENTION!
>>> pixelformat=YU12 lors des 1er tests?? 

*******>> sudo nano /boot/firmware/configtxt
=> rajout de "camera_autodetect=0"
--***** USING legacy camera stack AND not libcamera :
https://robotics.stackexchange.com/questions/23967/raspberry-pi-ros-2-humble-on-ubuntu-22-04-server-v4l2-camera-reports-failed
--
--***** ROS 2 v4l2 camera :
https://gitlab.com/boldhearts/ros2_v4l2_camera
--

---- Ensuite, après un SUDO REBOOt, la caméra donne :
>>  vcgencmd get_camera
supported=1 detected=1, libcamera interfaces=0 (MEME CHOSE LORSQU'on rajoute "camera_auto_detected=1"?
)

>> v4l2-ctl --list-devices
=> mmal service 16.1 (platform:bcm2835-v4l2-0):
	/dev/video0

>> v4l2-ctl --device=/dev/video0 --all
=>
Format Video Capture:
	Width/Height      : 1024/768
	Pixel Format      : 'JPEG' (JFIF JPEG)
	Field             : None
	Bytes per Line    : 0
	Size Image        : 786432
	Colorspace        : JPEG
	Transfer Function : Default (maps to sRGB)
	YCbCr/HSV Encoding: Default (maps to ITU-R 601)
	Quantization      : Default (maps to Full Range)
	Flags             : 
Format Video Overlay:
	Left/Top    : 150/50
	Width/Height: 1024/768
	Field       : None
	Chroma Key  : 0x00000000
	Global Alpha: 0xff
	Clip Count  : 0
	Clip Bitmap : No
Framebuffer Format:
	Capability    : Extern Overlay
			Global Alpha
	Flags         : Overlay Matches Capture/Output Size
	Width         : 1024
	Height        : 768
	Pixel Format  : 'YU12'




------------ (optionnel)
-mettre à jour manuellement les format/taille des pixels :
revient aux valeurs par défaut après un redémarrage!
>>
sudo apt remove libcamera-tools libcamera-dev libcamera0
sudo apt autoremove

>>
lsmod | grep bcm2835_v4l2


>> 
v4l2-ctl --device=/dev/video0 --set-fmt-video=width=640,height=480,pixelformat=JPEG; 

>>
v4l2-ctl --device=/dev/video0 --set-fmt-overlay=width=640,height=480,pixelformat=JPEG;

>>******** CAPTURE
v4l2-ctl --device=/dev/video0 --set-fmt-video=width=640,height=480,pixelformat=YUYV --stream-mmap --stream-count=1 --stream-to=image.raw

>>*********
-
autres formats:'RGGB', etc (voir: v4l2-ctl --device=/dev/video0 --list-formats)
------------




________________Si j'étais en simulation(VMWARE)
-------- Si j'étais en simulation(VMWARE), et que je veux maintenant passer sur le pi (télécharger ces logiciels, téléchargés précédemment):
***>>>>> sudo apt install ros-humble-image-transport-plugins ros-humble-rqt-image-view
-
>> Maintenant on peut lancer la vidéo à partir du NOEUD DRIVER LINUX 
>> ros2 run v4l2_camera v4l2_camera_node --ros-args -p image_size:="[800,608]" -p camera_frame_id:=camera_link_optical
-
>> IGNORER LES ERREURS... CALIBRATION FILE??
>> ros2 run rqt_image_view rqt_image_view; topic= .../compressed
----
>> ros2 launch camera.launch.py
>> ros2 run rqt_image_view rqt_image_view

--
REAL CAMERA INTEGRATION - end : si tout est ok; sinon lignes d'après... 

___________ REAL CAMERA - END ________



_______ LIBCAMERA/V4L2 :
>> 
https://forums.raspberrypi.com/viewtopic.php?t=352011

>>
--***** USING legacy camera stack AND not libcamera :
https://robotics.stackexchange.com/questions/23967/raspberry-pi-ros-2-humble-on-ubuntu-22-04-server-v4l2-camera-reports-failed
--
--***** ROS 2 v4l2 camera :
https://gitlab.com/boldhearts/ros2_v4l2_camera
_______ LIBCAMERA/V4L2 :


----------------------- cmd

--- périphériques vidéos connectés/détectés:
Tester chaque périphérique
Si vous savez quel périphérique correspond à votre caméra, vous pouvez tester son fonctionnement avec la commande suivante pour voir s'il fournit une sortie vidéo :
-
v4l2-ctl --device=/dev/video0 --list-formats

-------
Utilisation de v4l2-ctl pour vérifier les flux vidéo ::
>> 
v4l2-ctl --device=/dev/video0 --all
-
Cela affichera les caractéristiques de la caméra connectée au périphérique /dev/video0.



---
Si vous souhaitez utiliser la caméra dans une simulation avec ROS2 :

Vous pouvez utiliser un driver comme usb_cam ou v4l2_camera pour publier le flux vidéo de votre caméra dans ROS2. Vous devrez probablement ajuster la configuration pour utiliser le périphérique /dev/video0 ou un autre périphérique, en fonction de vos tests.

------------------------- cmd



---------- ERROR ERROR ERROR : en incluant camera.xacro -----------
****** EVITER DE FAIRE COMMUNIQUER LES MACHINES ROS2

>> le système crash: gazebo, rviz…

>> https://stackoverflow.com/questions/47150110/error-context-mismatch-in-svga-sampler-view-destroy-running-gui-programs-on-ub
---------- ERROR ERROR ERROR -----------


############################# Suite projet - CAMERA - ROS2







############ END - NOTES ############
